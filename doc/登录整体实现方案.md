# 登录功能整体实现方案

## 一、项目概述

### 1.1 功能目标
实现一个完整的用户登录系统，包括：
- 用户注册
- 用户登录
- Token 认证
- 权限管理
- 登录状态持久化
- 自动登录/退出

### 1.2 技术栈
- **前端框架**: Next.js 15.5.5 + React 19.1.0
- **UI 组件**: shadcn/ui
- **样式**: Tailwind CSS v4
- **数据库**: MySQL
- **ORM**: Prisma
- **HTTP 客户端**: Axios
- **状态管理**: Context API + localStorage
- **认证方式**: JWT Token

---

## 二、架构设计

### 2.1 目录结构

```
ecloud_next_scaffold/
├── app/
│   ├── api/                    # 后端 API 路由
│   │   ├── auth/
│   │   │   ├── login/
│   │   │   │   └── route.js   # 登录接口
│   │   │   ├── register/
│   │   │   │   └── route.js   # 注册接口
│   │   │   ├── logout/
│   │   │   │   └── route.js   # 登出接口
│   │   │   └── refresh/
│   │   │       └── route.js   # 刷新 Token
│   │   └── user/
│   │       ├── profile/
│   │       │   └── route.js   # 获取用户信息
│   │       └── update/
│   │           └── route.js   # 更新用户信息
│   │
│   ├── components/             # 前端页面组件
│   │   ├── home/              # 首页
│   │   │   └── page.jsx
│   │   ├── login/             # 登录页
│   │   │   └── page.jsx
│   │   ├── register/          # 注册页
│   │   │   └── page.jsx
│   │   └── layout/            # 布局组件
│   │       ├── AppLayout.jsx  # 主布局（左菜单+上栏+内容）
│   │       ├── Sidebar.jsx    # 左侧菜单
│   │       ├── Header.jsx     # 顶部信息栏
│   │       └── Content.jsx    # 内容区域
│   │
│   ├── layout.js              # 根布局
│   └── page.js                # 根页面（重定向）
│
├── src/
│   ├── lib/
│   │   ├── prisma.js          # Prisma 客户端
│   │   ├── axios.js           # Axios 通用封装
│   │   ├── jwt.js             # JWT 工具函数
│   │   └── password.js        # 密码加密工具
│   │
│   ├── contexts/
│   │   ├── AuthContext.js     # 认证状态管理
│   │   └── ThemeContext.js    # 主题管理（已存在）
│   │
│   ├── hooks/
│   │   ├── useAuth.js         # 认证 Hook
│   │   └── useRequest.js      # 请求 Hook
│   │
│   ├── middleware/
│   │   └── auth.js            # API 认证中间件
│   │
│   └── utils/
│       ├── storage.js         # localStorage 封装
│       └── validator.js       # 表单验证工具
│
├── prisma/
│   ├── schema.prisma          # 数据库模型定义
│   └── migrations/            # 数据库迁移文件
│
└── doc/
    └── 登录整体实现方案.md
```

### 2.2 数据流向

```
用户操作 → 前端组件 → Axios 请求 → API 路由 → Prisma → MySQL
                                    ↓
                               JWT Token
                                    ↓
                          AuthContext（状态管理）
                                    ↓
                            localStorage（持久化）
```

---

## 三、数据库设计

### 3.1 Prisma Schema

```prisma
// prisma/schema.prisma

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "mysql"
  url      = env("DATABASE_URL")
}

// 用户表
model User {
  id        Int      @id @default(autoincrement())
  email     String   @unique
  username  String   @unique
  password  String   // 加密后的密码
  nickname  String?
  avatar    String?  // 头像 URL
  role      Role     @default(USER)
  status    Status   @default(ACTIVE)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // 关联表
  sessions  Session[]
  logs      LoginLog[]
}

// 用户角色枚举
enum Role {
  ADMIN     // 管理员
  USER      // 普通用户
  GUEST     // 访客
}

// 用户状态枚举
enum Status {
  ACTIVE    // 激活
  INACTIVE  // 停用
  BANNED    // 封禁
}

// 会话表（可选，用于记录登录会话）
model Session {
  id           String   @id @default(uuid())
  userId       Int
  token        String   @unique
  refreshToken String?  @unique
  ip           String?
  userAgent    String?
  expiresAt    DateTime
  createdAt    DateTime @default(now())

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
}

// 登录日志表（可选，用于审计）
model LoginLog {
  id        Int      @id @default(autoincrement())
  userId    Int
  ip        String?
  userAgent String?
  action    String   // LOGIN, LOGOUT, REFRESH
  success   Boolean
  message   String?
  createdAt DateTime @default(now())

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([createdAt])
}
```

### 3.2 数据库初始化命令

```bash
# 1. 初始化 Prisma
npx prisma init

# 2. 配置 .env 文件
DATABASE_URL="mysql://user:password@localhost:3306/ecloud_db"

# 3. 生成迁移文件
npx prisma migrate dev --name init

# 4. 生成 Prisma Client
npx prisma generate

# 5. 可视化数据库（可选）
npx prisma studio
```

---

## 四、后端 API 设计

### 4.1 API 接口列表

| 接口路径 | 方法 | 功能 | 是否需要认证 |
|---------|------|------|-------------|
| `/api/auth/register` | POST | 用户注册 | ❌ |
| `/api/auth/login` | POST | 用户登录 | ❌ |
| `/api/auth/logout` | POST | 用户登出 | ✅ |
| `/api/auth/refresh` | POST | 刷新 Token | ✅ |
| `/api/user/profile` | GET | 获取用户信息 | ✅ |
| `/api/user/update` | PUT | 更新用户信息 | ✅ |

### 4.2 接口详细设计

#### 4.2.1 注册接口

**请求：**
```json
POST /api/auth/register
Content-Type: application/json

{
  "email": "user@example.com",
  "username": "username",
  "password": "password123",
  "nickname": "昵称"
}
```

**响应：**
```json
{
  "code": 200,
  "message": "注册成功",
  "data": {
    "user": {
      "id": 1,
      "email": "user@example.com",
      "username": "username",
      "nickname": "昵称"
    }
  }
}
```

#### 4.2.2 登录接口

**请求：**
```json
POST /api/auth/login
Content-Type: application/json

{
  "username": "username",  // 或 email
  "password": "password123"
}
```

**响应：**
```json
{
  "code": 200,
  "message": "登录成功",
  "data": {
    "token": "eyJhbGciOiJIUzI1NiIs...",
    "refreshToken": "eyJhbGciOiJIUzI1NiIs...",
    "expiresIn": 7200,
    "user": {
      "id": 1,
      "email": "user@example.com",
      "username": "username",
      "nickname": "昵称",
      "avatar": "https://...",
      "role": "USER"
    }
  }
}
```

#### 4.2.3 登出接口

**请求：**
```json
POST /api/auth/logout
Authorization: Bearer <token>
```

**响应：**
```json
{
  "code": 200,
  "message": "登出成功"
}
```

#### 4.2.4 刷新 Token 接口

**请求：**
```json
POST /api/auth/refresh
Content-Type: application/json

{
  "refreshToken": "eyJhbGciOiJIUzI1NiIs..."
}
```

**响应：**
```json
{
  "code": 200,
  "message": "刷新成功",
  "data": {
    "token": "eyJhbGciOiJIUzI1NiIs...",
    "expiresIn": 7200
  }
}
```

### 4.3 统一响应格式

```javascript
// 成功响应
{
  "code": 200,
  "message": "操作成功",
  "data": { ... }
}

// 失败响应
{
  "code": 400,     // 或其他错误码
  "message": "错误信息",
  "error": "详细错误描述"
}
```

### 4.4 HTTP 状态码约定

| 状态码 | 说明 |
|--------|------|
| 200 | 成功 |
| 400 | 请求参数错误 |
| 401 | 未认证/Token 失效 |
| 403 | 无权限 |
| 404 | 资源不存在 |
| 500 | 服务器错误 |

---

## 五、前端实现方案

### 5.1 Axios 封装

**文件：`src/lib/axios.js`**

```javascript
import axios from 'axios';
import { getToken, removeToken } from '@/utils/storage';

// 创建 axios 实例
const request = axios.create({
  baseURL: process.env.NEXT_PUBLIC_API_URL || '/api',
  timeout: 10000,
  headers: {
    'Content-Type': 'application/json',
  },
});

// 请求拦截器
request.interceptors.request.use(
  (config) => {
    // 自动添加 Token
    const token = getToken();
    if (token) {
      config.headers.Authorization = `Bearer ${token}`;
    }
    return config;
  },
  (error) => {
    return Promise.reject(error);
  }
);

// 响应拦截器
request.interceptors.response.use(
  (response) => {
    const res = response.data;

    // 统一处理响应
    if (res.code !== 200) {
      // 处理业务错误
      return Promise.reject(new Error(res.message || '请求失败'));
    }

    return res;
  },
  (error) => {
    // 处理 HTTP 错误
    if (error.response) {
      switch (error.response.status) {
        case 401:
          // Token 失效，清除并跳转登录
          removeToken();
          window.location.href = '/components/login';
          break;
        case 403:
          console.error('无权限访问');
          break;
        case 500:
          console.error('服务器错误');
          break;
      }
    }
    return Promise.reject(error);
  }
);

// 导出通用请求方法
export const get = (url, params) => request.get(url, { params });
export const post = (url, data) => request.post(url, data);
export const put = (url, data) => request.put(url, data);
export const del = (url) => request.delete(url);

export default request;
```

### 5.2 认证状态管理

**文件：`src/contexts/AuthContext.js`**

```javascript
"use client";

import { createContext, useContext, useEffect, useState } from "react";
import { useRouter } from "next/navigation";
import { post } from "@/lib/axios";
import { getToken, setToken, removeToken, getUser, setUser, removeUser } from "@/utils/storage";

const AuthContext = createContext({});

export function AuthProvider({ children }) {
  const [user, setUserState] = useState(null);
  const [loading, setLoading] = useState(true);
  const router = useRouter();

  // 初始化：从 localStorage 读取用户信息
  useEffect(() => {
    const token = getToken();
    const savedUser = getUser();

    if (token && savedUser) {
      setUserState(savedUser);
    }

    setLoading(false);
  }, []);

  // 登录
  const login = async (credentials) => {
    try {
      const res = await post('/auth/login', credentials);
      const { token, user } = res.data;

      // 保存 Token 和用户信息
      setToken(token);
      setUser(user);
      setUserState(user);

      return { success: true };
    } catch (error) {
      return { success: false, error: error.message };
    }
  };

  // 登出
  const logout = async () => {
    try {
      await post('/auth/logout');
    } catch (error) {
      console.error('登出失败', error);
    } finally {
      // 清除本地数据
      removeToken();
      removeUser();
      setUserState(null);
      router.push('/components/login');
    }
  };

  // 注册
  const register = async (data) => {
    try {
      await post('/auth/register', data);
      return { success: true };
    } catch (error) {
      return { success: false, error: error.message };
    }
  };

  const value = {
    user,
    loading,
    login,
    logout,
    register,
    isAuthenticated: !!user,
  };

  return <AuthContext.Provider value={value}>{children}</AuthContext.Provider>;
}

export function useAuth() {
  const context = useContext(AuthContext);
  if (context === undefined) {
    throw new Error('useAuth must be used within AuthProvider');
  }
  return context;
}
```

### 5.3 布局设计

#### 5.3.1 主布局结构

```
┌─────────────────────────────────────────┐
│            Header (顶部信息栏)            │
│  Logo | 用户信息 | 主题切换 | 退出        │
├──────────┬──────────────────────────────┤
│          │                              │
│  Sidebar │        Content               │
│ (左菜单)  │       (内容区域)              │
│          │                              │
│  - 首页   │                              │
│  - 用户   │                              │
│  - 设置   │                              │
│          │                              │
└──────────┴──────────────────────────────┘
```

#### 5.3.2 组件说明

**AppLayout.jsx**: 主布局容器
- 左侧固定宽度菜单（240px）
- 右侧自适应内容区
- 顶部固定高度信息栏（64px）

**Sidebar.jsx**: 左侧菜单
- 菜单项列表
- 高亮当前路由
- 折叠/展开功能（可选）

**Header.jsx**: 顶部信息栏
- Logo
- 用户头像和昵称
- 主题切换器
- 退出按钮

**Content.jsx**: 内容区域
- 显示路由对应的页面组件

### 5.4 路由保护

```javascript
// src/middleware/auth.js
export function requireAuth(handler) {
  return async (req, res) => {
    const token = req.headers.authorization?.replace('Bearer ', '');

    if (!token) {
      return res.status(401).json({
        code: 401,
        message: '未认证'
      });
    }

    try {
      const decoded = verifyToken(token);
      req.user = decoded;
      return handler(req, res);
    } catch (error) {
      return res.status(401).json({
        code: 401,
        message: 'Token 无效'
      });
    }
  };
}
```

---

## 六、安全设计

### 6.1 密码加密

使用 `bcrypt` 进行密码哈希：

```javascript
// src/lib/password.js
import bcrypt from 'bcryptjs';

export async function hashPassword(password) {
  const salt = await bcrypt.genSalt(10);
  return bcrypt.hash(password, salt);
}

export async function verifyPassword(password, hash) {
  return bcrypt.compare(password, hash);
}
```

### 6.2 JWT Token

```javascript
// src/lib/jwt.js
import jwt from 'jsonwebtoken';

const SECRET = process.env.JWT_SECRET || 'your-secret-key';
const EXPIRES_IN = '2h';  // Token 有效期

export function signToken(payload) {
  return jwt.sign(payload, SECRET, { expiresIn: EXPIRES_IN });
}

export function verifyToken(token) {
  try {
    return jwt.verify(token, SECRET);
  } catch (error) {
    throw new Error('Token 无效或已过期');
  }
}
```

### 6.3 环境变量

```env
# .env.local

# 数据库
DATABASE_URL="mysql://user:password@localhost:3306/ecloud_db"

# JWT
JWT_SECRET="your-super-secret-key-change-in-production"
JWT_EXPIRES_IN="2h"

# Refresh Token
REFRESH_TOKEN_SECRET="your-refresh-token-secret"
REFRESH_TOKEN_EXPIRES_IN="7d"

# API
NEXT_PUBLIC_API_URL="http://localhost:3000/api"
```

---

## 七、实施步骤

### 阶段一：基础环境搭建（第 1 天）

1. ✅ 安装 Prisma 和相关依赖
2. ✅ 配置 Prisma Schema
3. ✅ 初始化数据库
4. ✅ 安装 Axios、bcrypt、jsonwebtoken

### 阶段二：后端 API 开发（第 2-3 天）

1. ✅ 封装 Prisma 客户端
2. ✅ 实现密码加密工具
3. ✅ 实现 JWT 工具
4. ✅ 开发注册接口
5. ✅ 开发登录接口
6. ✅ 开发登出接口
7. ✅ 开发用户信息接口
8. ✅ 实现认证中间件

### 阶段三：前端基础设施（第 4 天）

1. ✅ 封装 Axios 请求工具
2. ✅ 实现 localStorage 工具
3. ✅ 创建 AuthContext
4. ✅ 实现 useAuth Hook

### 阶段四：页面开发（第 5-6 天）

1. ✅ 开发登录页面
2. ✅ 开发注册页面
3. ✅ 开发主布局（AppLayout）
4. ✅ 开发侧边菜单（Sidebar）
5. ✅ 开发顶部栏（Header）
6. ✅ 开发首页（Home）

### 阶段五：测试与优化（第 7 天）

1. ✅ 功能测试
2. ✅ 错误处理完善
3. ✅ 性能优化
4. ✅ 文档完善

---

## 八、依赖包清单

```json
{
  "dependencies": {
    "@prisma/client": "^6.x.x",
    "axios": "^1.7.x",
    "bcryptjs": "^2.4.x",
    "jsonwebtoken": "^9.0.x"
  },
  "devDependencies": {
    "prisma": "^6.x.x"
  }
}
```

---

## 九、注意事项

### 9.1 安全考虑

1. ✅ 密码必须加密存储
2. ✅ Token 设置合理的过期时间
3. ✅ 使用 HTTPS（生产环境）
4. ✅ 防止 SQL 注入（Prisma 自动防护）
5. ✅ 限制登录失败次数（可选）
6. ✅ 记录登录日志（可选）

### 9.2 用户体验

1. ✅ 友好的错误提示
2. ✅ Loading 状态显示
3. ✅ 自动跳转
4. ✅ 记住登录状态
5. ✅ Token 自动刷新（可选）

### 9.3 代码规范

1. ✅ 统一的响应格式
2. ✅ 统一的错误处理
3. ✅ 清晰的目录结构
4. ✅ 完善的注释
5. ✅ 可复用的组件

---

## 十、后续扩展

### 10.1 功能扩展

- [ ] 忘记密码/重置密码
- [ ] 邮箱验证
- [ ] 第三方登录（OAuth）
- [ ] 双因素认证（2FA）
- [ ] 用户权限管理（RBAC）
- [ ] 用户头像上传
- [ ] 登录设备管理

### 10.2 技术优化

- [ ] Token 自动刷新机制
- [ ] 请求队列管理
- [ ] 接口缓存策略
- [ ] SSR 支持优化
- [ ] 性能监控

---

## 十一、总结

本方案设计遵循以下原则：

1. **简单易用**：API 设计简洁，前端调用方便
2. **通用可复用**：Axios 封装、AuthContext 可在项目中广泛使用
3. **安全可靠**：密码加密、JWT 认证、中间件保护
4. **易于维护**：清晰的目录结构，统一的代码规范
5. **可扩展性**：预留扩展接口，支持功能增强

通过本方案，可以快速搭建一个生产级的登录系统，并为后续功能开发打下坚实基础。
